\chapter{Implementation}
\label{cha:implementation}
In this chapter, we will briefly describe the program components---%
roughly split into the geometry and the optimization part.
To let the program run close to the hardware layer (which usually
leads to fast execution times), the code was written in C++. First
attempts to use Python instead (for the sake of clarity and better
readability) stumbled over the non-readiness of the \gls{CGAL} bindings and
the lack of good alternatives. For the technical documentation,
please refer to \cref{cha:documentation}.

\section{Geometry}
The geometry part consists of number, point, and segment types, 
data structures for triangulation, convex hull, and bounding box, 
and it also handles the segment intersection. For most of it we
made extensive use of \gls{CGAL}, which will be introduced in \cref{sec:CGAL}.

\subsection{CGAL}
\label{sec:CGAL}
\gls{CGAL} \cite{cgal} is an Open Source library (mainly) for computational
geometry written in C++. It includes most of the common algorithms in
the field and also offers efficient data structures. Through the use
of C++ templates it is flexible and extendable: For example it is
common to adjust the underlying number types to the application.

\subsection{Kernel}
A kernel in \gls{CGAL} is something like a computational geometry operating
system: It holds the basic type definitions like numbers, points,
lines, and line segments. Basic operations such as intersection,
angle calculations, or comparisons are also part of it.

In our application we use the built-in 
\verb|Exact_predicates_inexact_constructions_kernel|%
\footnote{Thanks to Michael Hemmer for making me aware that I should
use it!}~\cite{cgal_manual_epick}, which uses double as a number type
and is not capable of constructing new geometric objects from existing
ones accurately. Both properties lead to faster execution time yet do 
not produce wrong results in our case.

On top of the \gls{CGAL} kernel there are two modifications: One is for
printing points and segments without the need to use streams, the
other one to output them to SVG (see also
\cref{sec:Qt,sec:svg_painter}). Additionally segments are indexed by
length and have the information whether they overlap with other
segments attached to them.

\subsection{Triangulation}
\gls{CGAL} brings along a constrained triangulation already
\cite{cgal_manual_constrained_triangulation}
which triangulates a point set with respect to a given mandatory set
of (non-crossing) edges. For this application the class was extended
to be drawable to SVG and to find the shortest edge which is part of
the triangulation.

\subsection{Convex Hull}
This class directly calls the \verb|convex_hull_2| function of \gls{CGAL}
\cite{cgal_manual_convex_hull} which itself defaults to the algorithm
of Akl \& Toussaint \cite{convex_hull}. The only extension is that
the class serves as container
which holds the output points and contains a function to find the 
shortest segment within.

For the algorithm this class is not necessary as its bound is worse
than the one of the SAT solution. It is left in the implementation
though as a measure of quality for the other bound.

\subsection{Intersection Algorithm}
To find all pairs of intersecting segments we use 
\cref{alg:naive_intersection}. For the intersection check itself
we make use of the \gls{CGAL} function \verb|do_intersect|%
~\cite{cgal_manual_do_intersect}. In contrast to the
\verb|intersecttion| function~\cite{cgal_manual_intersection}, it
does not actually compute the intersection and therefore performs
much better.\footnote{Thanks again to Michael Hemmer!}

\subsection{Intersection Graph}
The intersection graph (as defined in \cref{def:intersection_graph})
stores for every segment the indices of all intersecting segments.
This graph data structure (adjacency list) performs well for few
edges (in this case intersections) per vertex (in this case line
segment)---which we assume here. It may however in future versions
of the implementation be replaced by a sparse adjacency matrix from
the \cref{sec:boost} library.

\section{Optimization}
The optimization part itself consists mainly of data structures for
SAT problems and solutions, an interface for SAT solvers and the
solvers themselves (currently only CPLEX).

Only segment indices and intersections are passed to the SAT problem.
This is because geometry does not influence the problem, but only
topology. Also it is easier that way to keep track of which segments
take part in the restrictions.

\subsection{SAT problem}
This class serves two purposes: To grant an interface to the relevant
data for the SAT (i.e. segments and intersections) and to set the
short segment range.

\subsection{SAT solution}
The SAT solution class mainly just stores the segment indices derived
from solving the SAT problem --- which can be none if no feasible
solution is found. Additionally it offers methods for drawing short
segments and separators and for finding the shortest segment of the
solution.

\subsection{SAT solver}
To unify the way solving the SAT problem is done, there are three
interfaces: The base SAT solver and two derived interfaces for
decision and optimization problems. They all share methods for adding
forbidden segments, intersection and separation restrictions and for
running the actual solving. Furthermore there is a method for binding
short segments to the objective function for optimization problems.

\subsection{CPLEX}
\label{sec:cplex}
IBM ILOG CPLEX \cite{cplex}
is a commercial optimization suite written in C. It contains a
standalone tool for solving optimization problems and also includes
libraries for being used in other programs or even other programming
languages. According to \cite{cplex_benchmark}
CPLEX is one of the two fastest MILP solvers.

In our application we use the Concert API for C++ \cite{cplex_concert}
to access CPLEX. It allows for adding variables and restrictions to
a model, extracting them to more efficient data structures and then
running several solving algorithms on it.

\section{Remaining Components}
Besides the geometry and optimization parts, our implementation
contains the following components: A controller
class for the whole algorithm which combines all the other components
and utility classes for reading input files, debug
output and assertions, test case generation, and drawing certain 
states of the algorithm to SVG.

\subsection{Boost}
\label{sec:boost}
Boost~\cite{boost} is a collection of free (as in freedom) C++
libraries containing tools for various tasks. It makes extensive use
of the C++ pre-processor (mostly templates) and aims to extend the
C++ standard library (STL).

In our implementation, we use the Spirit~\cite{boost_spirit} library
for parsing the JSON input files (see \cref{sec:json_parser}), and
the Program Options library~\cite{boost_program_options} for parsing
command line arguments and configuration files. Later versions of the
implementation may as well use the Boost Graph
Library~\cite{boost_graph} for the intersection graph, and the
Geometry library~\cite{boost_geometry} for creating SVG images
(see \cref{sec:svg_painter}).

\subsection{Qt}
\label{sec:Qt}
Qt~\cite{qt} is a framework for cross-platform application development
written in C++. It features some enhancements to the C++ standard
library including an own string class
\verb|QString|~\cite{qt_manual_qstring} which supports
a different formatting syntax than the \verb|std::string|, offers
a UI description format with integration into a even processing
framework, and also comes with a simplified built system qmake which
wraps platform dependent tools such as GNU make.

We make use of \verb|QString| for our logger class
(\cref{sec:logger}), generate SVG images through the \verb|QPainter|
class, and build our applications using qmake (which also allows
for integration in the C++ IDE Qtcreator).

\subsection{JSON Parser}
\label{sec:json_parser}
JSON Spirit \cite{json_spirit} uses the Boost Spirit
library~\cite{boost_spirit} for parsing the input point files in
JSON (JavaScript Object Notation)~\cite{json} format. As of writing,
the built-in JSON support of Qt unfortunately has a
bug~\cite{json_bug} such that it is not compatible with the C++
standard library (and therefore also neither with \gls{CGAL} nor with
Boost). After parsing the input file, all points are stored in a
sorted set to allow for fast lookup.

\subsection{Logger}
\label{sec:logger}
Our logger class supports different levels of verbosity
(debug, info, error, print) and adds the current timestamp to each
of them. Additionally, there are shortcut methods for output of
measured times, and the current status of the algorithm. Debug output
is only included in the programs if they are compiled in debug mode.
For convenience, all methods accept \verb|QString|.

\subsection{Point Generator}
For testing and analyzing the algorithm, we generated different
instances of point sets and stored them for repeated runs. We hereby
rely on the \verb|Random_points_in_square_2| 
class~\cite{cgal_manual_random_points} in combination with the
\verb|Creator_uniform_2| class~\cite{cgal_manual_creator_uniform}---both
part of \gls{CGAL} (\cref{sec:CGAL}).

\subsection{SVG Painter}
\label{sec:svg_painter}
Mainly for debugging purposes and to visualize different steps of the
algorithm, we included the possibility to draw certain data structures
to SVG using the \verb|QPainter| class~\cite{qt_manual_qpainter}.

%---------------------------------------------------------------------##########
