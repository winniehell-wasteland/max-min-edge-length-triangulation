\chapter{Implementation}
To get his algorithm implemented Greg asked Winfried Hellmann, a
friend of him who studied computer science. He instantly agreed and
started to plan the structure. There were two main components:
Geometry and Optimization.

To let the program run close to the hardware layer (which usually
leads to fast execution times), the code was written in C++. First
attempts to use Python instead (for the sake of clarity and better
readability) stumbled over the non-readiness of the CGAL bindings and
the lack of good alternatives.

\section{Geometry}
The geometry part consists now of the basics like number, point, and
segment types, data structures for triangulation and convex hull, and
the intersection algorithm. For most of it Winfried made extensive use
of CGAL, which will be introduced in \cref{sec:CGAL}.

\subsection{CGAL}\label{sec:CGAL}
CGAL \cite{cgal} is an Open Source library (mainly) for computational
geometry written in C++. It includes most of the common algorithms in
the field and also offers efficient data structures. Through the use
of C++ templates it is flexible and extendable: For example it is
common to adjust the underlying number types to the application.

\subsection{Kernel}
A kernel in CGAL is something like a computational geometry operating
system: It holds the basic type definitions like numbers, points,
lines, and line segments. Basic operations such as intersection,
angle calculations, or comparisons are also part of it.

In our application we use the built-in 
\verb|Exact_predicates_inexact_constructions_kernel|%
\footnote{Thanks to Michael Hemmer for making me aware that I should
use it!} \cite{cgal_manual_epick}, which uses double as a number type
and is not capable of
constructing new objects from existing ones accurately. Both
properties lead to faster execution time yet do not produce wrong
results in our case.

On top of the CGAL kernel there are two modifications: One is for
printing points and segments without the need to use streams, the
other one to output them to SVG (see also
\cref{sec:Qt,sec:SVG_Painter}). Additionally segments are indexed by
length and have the information whether they overlap with other
segments attached to them.

\subsection{Triangulation}
CGAL brings along a constrained triangulation already
\cite{cgal_manual_constrained_triangulation}
which triangulates a point set with respect to a given mandatory set
of (non-crossing) edges. For this application the class was extended
to be drawable to SVG and to find the shortest edge which is part of
the triangulation.

\subsection{Convex Hull}
This class directly calls the \verb|convex_hull_2| function of CGAL
\cite{cgal_manual_convex_hull} which itself defaults to the algorithm
of Akl \& Toussaint \cite{convex_hull}. The only extension is that
the class serves as container
which holds the output points and contains a function to find the 
shortest segment within.

For the algorithm this class is not necessary as its bound is worse
than the one of the SAT solution. It is left in the implementation
though as a measure of quality for the other bound.

\section{Optimization}
The optimization part itself consists mainly of data structures for
SAT problems and solutions, an interface for SAT solvers and the
solvers themselves (currently only CPLEX).

\section{Remains}
And then there is the rest: A controller
class for the whole algorithm which combines all the other components
and utility classes for reading input files, debug
output and assertions, test case generation, and drawing certain 
states of the algorithm to SVG.

\subsection{Qt}\label{sec:Qt}
