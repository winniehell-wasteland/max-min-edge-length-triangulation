\chapter{Implementation}
To get his algorithm implemented Greg asked Winfried Hellmann, a
friend of him who studied computer science. He instantly agreed and
started to plan the structure. There were two main components:
Geometry and Optimization.

To let the program run close to the hardware layer (which usually
leads to fast execution times), the code was written in C++. First
attempts to use Python instead (for the sake of clarity and better
readability) stumbled over the non-readiness of the CGAL bindings and
the lack of good alternatives.

\section{Geometry}
The geometry part consists now of the basics like number, point, and
segment types, data structures for triangulation and convex hull, and
the intersection algorithm. For most of it Winfried made extensive use
of CGAL, which will be introduced in \cref{sec:CGAL}.

\subsection{CGAL}\label{sec:CGAL}
CGAL \cite{cgal} is an Open Source library (mainly) for computational
geometry written in C++. It includes most of the common algorithms in
the field and also offers efficient data structures. Through the use
of C++ templates it is flexible and extendable: For example it is
common to adjust the underlying number types to the application.

\subsection{Kernel}
A kernel in CGAL is something like a computational geometry operating
system: It holds the basic type definitions like numbers, points,
lines, and line segments. Basic operations such as intersection,
angle calculations, or comparisons are also part of it.

In our application we use the built-in 
\verb|Exact_predicates_inexact_constructions_kernel|%
\footnote{Thanks to Michael Hemmer for making me aware that I should
use it!} \cite{cgal_manual_epick}, which uses double as a number type
and is not capable of
constructing new objects from existing ones accurately. Both
properties lead to faster execution time yet do not produce wrong
results in our case.

On top of the CGAL kernel there are two modifications: One is for
printing points and segments without the need to use streams, the
other one to output them to SVG (see also
\cref{sec:Qt,sec:SVG_Painter}). Additionally segments are indexed by
length and have the information whether they overlap with other
segments attached to them.

\subsection{Triangulation}
CGAL brings along a constrained triangulation already
\cite{cgal_manual_constrained_triangulation}
which triangulates a point set with respect to a given mandatory set
of (non-crossing) edges. For this application the class was extended
to be drawable to SVG and to find the shortest edge which is part of
the triangulation.

\subsection{Convex Hull}
This class directly calls the \verb|convex_hull_2| function of CGAL
\cite{cgal_manual_convex_hull} which itself defaults to the algorithm
of Akl \& Toussaint \cite{convex_hull}. The only extension is that
the class serves as container
which holds the output points and contains a function to find the 
shortest segment within.

For the algorithm this class is not necessary as its bound is worse
than the one of the SAT solution. It is left in the implementation
though as a measure of quality for the other bound.

\section{Optimization}
The optimization part itself consists mainly of data structures for
SAT problems and solutions, an interface for SAT solvers and the
solvers themselves (currently only CPLEX).

Only segment indices and intersections are passed to the SAT problem.
This is because geometry does not influence the problem, but only
topology. Also it is easier that way to keep track of which segments
take part in the restrictions.

\subsection{SAT problem}
This class serves two purposes: To grant an interface to the relevant
data for the SAT (i.e. segments and intersections) and to set the
short segment range.

\subsection{SAT solution}
The SAT solution class mainly just stores the segment indices derived
from solving the SAT problem --- which can be none if no feasible
solution is found. Additionally it offers methods for drawing short
segments and separators and for finding the shortest segment of the
solution.

\subsection{SAT solver}
To unify the way solving the SAT problem is done, there are three
interfaces: The base SAT solver and two derived interfaces for
decision and optimization problems. They all share methods for adding
forbidden segments, intersection and separation restrictions and for
running the actual solving. Furthermore there is a method for binding
short segments to the objective function for optimization problems.

\subsection{CPLEX}
IBM ILOG CPLEX
\url{https://www.ibm.com/software/commerce/optimization/cplex-optimizer/}
is a commercial optimization suite written in C. It contains a
standalone tool for solving optimization problems and also includes
libraries for being used in other programs or even other programming
languages. According to 
\url{http://plato.asu.edu/ftp/milpc.html} 
CPLEX is one of the two fastest MILP solvers.

In our application we use the Concert API for C++
\url{http://pic.dhe.ibm.com/infocenter/cosinfoc/v12r2/topic/ilog.odms.cplex.help/Content/Optimization/Documentation/CPLEX/_pubskel/CPLEX197.html}
to access CPLEX. It allows for adding variables and restrictions to
a model, extracting them to more efficient data structures and then
running several solving algorithms on it.

\section{Remains}
And then there is the rest: A controller
class for the whole algorithm which combines all the other components
and utility classes for reading input files, debug
output and assertions, test case generation, and drawing certain 
states of the algorithm to SVG.

\subsection{Qt}\label{sec:Qt}
